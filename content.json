{"pages":[{"title":"关于我","text":"","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"了解MVVM，从Vue实例出发","text":"MVVM的由来在过去的几年中，我们已经把很多传统的服务端代码放到了浏览器中，这样就产生了成千上万行的javascript代码，它们连接了各式各样的HTML 和CSS文件，但缺乏正规的组织形式，这也就是为什么越来越多的开发者使用javascript框架。比如：angular、react、vue。浏览器的兼容性问题已经不再是前端的阻碍。前端的项目越来越大，项目的可维护性和扩展性、安全性等成了主要问题。当年为了解决浏览器兼容性问题，出现了很多类库，其中最典型的就是jquery。但是这类库没有实现对业务逻辑的分成，所以维护性和扩展性极差。综上两方面原因，才有了MVVM模式一类框架的出现。比如vue,通过数据的双向绑定，极大了提高了开发效率。 MVVM的概述MVVM是Model-View-ViewModel的简写，它是一种前端视图层的分层开发思想，Model指的是传递的数据，View指的是页面的结构，而ViewModel是MVVM模式的核心，它是连接View和Model的桥梁，当数据变化时ViewModel能够监听到，然后使对应的视图做出自动更新，当视图变化使ViewModel也能监听到，从而使数据自动更新，这就实现了数据的双向绑定，这也是MVVM思想的好处。 采用MVVM模式的框架Vue Vue是一套用于构建用户界面的渐进式JavaScript框架，只关注视图层，方便与第三方库或既有项目整合 代码实例： 12345678910111213141516171819202122232425262728293031&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!--导入Vue的包--&gt; &lt;script src=\"./bin/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--Vue实例所控制的这个元素区域，就是我们的V--&gt; &lt;div id=\"app\"&gt; &lt;p&gt;{{msg}}&lt;/p&gt;&lt;/div&gt; &lt;script&gt; //创建一个Vue实例 //当我们导入包之后，在浏览器的内存中，就多了一个Vue构造函数 //new出来的这个vm对象，就是我们MVVM中的VM调度者 var vm = new Vue({ el: '#app', //表示当前new的这个Vue实例，要控制页面上的哪个区域 //这里的data就是MVVM中的M，专门用来存放数据 data: { //data属性中，存放的是el要用到的数据 msg: 'HelloWorld' //通过Vue提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了 } }） &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/03/30/mvvm/"},{"title":"网络层","text":"​ 网络层是OSI参考模型中的第三层，介于传输层和数据链路层之间，它在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的数据通信，将数据设法从源端经过若干个中间节点传送到目的端，从而向运输层提供最基本的端到端的数据传送服务。网络层有两个重要的功能，转发和路由选择，某些计算机网络中，还有第三种重要的网络功能：连接建立（如ATM、帧中继、MPLS）。 转发涉及分组在单一的路由器中从一条入链路到一条出链路的传送。路由选择涉及一个网络的所有路由器，他们经路由选择协议共同交互，以决定分组从源到目的地节点所采用的路径，决定这些路径的算法被称为路由选择算法。转发是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作；路由选择是指网络范围的过程，以决定分组从源到目的地所采用的端到端路径。 每台路由器具有一张转发表。路由器通过检查到达分组首部字段的值来转发分组，然后使用该值在该路由器的转发表中索引查询，找到该首部值对应的输出链路接口。 转发问题：编址和最长前缀匹配问题 转发表是由路由选择处理器计算和更新的，但转发表的一份影子副本通常会被存放在每个输入端口。有了影子副本，转发决策能在每个输入端口本地做出，无须调用中央路由选择处理器，避免了集中式处理的瓶颈。 路由选择算法决定了插入路由器的转发表中的值。 分组交换机是指一台通用分组交换设备，分组交换机分为链路分组交换机和路由器，链路分组交换机基于链路层字段中的值做转发决定。路由器基于网络层字段的值做转发决定。 网络层提供了一种单一的服务，尽力而为服务。 路由器的4个组成部分：输入端口、交换结构（核心部位）、输出端口、路由选择处理器 输入端口处理： 交换结构：三种交换技术：（1）经内存交换；（2）经总线交换；（3）经互联网络交换。 输出端口处理： 路由器缓存吸收流量负债的波动，需要的缓存数量应当等于平均往返时延乘以链路的容量。 排队引发的性能，丢包问题（稍后深入了解） 路由选择处理器： 通过路由选择算法进行路由处理，线路分发。 路由选择控制平面因特网的网络层三个主要组件：IP协议；路由选择部分；互联网控制报文协议。通过这些组件，网络层可以在复杂的网络中寻找到最合适的路径，将分组从源主机移动到目的主机。 IPv4：首部检验和的计算：将首部中每两个字节作为一个数，用反码运算对这些数字求和，该和的反码存放在检验和字段，被称为因特网检验和。如何数据包首部中携带的检验和与计算所得不一致，则认为检测出现差错。 为什么运输层和网络层都执行了差错检验？网络层只对IP首部计算检验和，而运输层是对整个报文段计算的。 TCP/UDP与IP不一定必须属于同一个协议栈，即TCP不一定运行在IP上 一些名词解释： 子网：互联某些主机与一个路由器接口的网络形成一个子网 子网掩码：IP编址为子网分配一个地址，如：223.1.1.0/24其中/24记法有时称为子网掩码，，指示了32比特中左侧24比特定义的子网地址，和要连接到223.1.1.0/24的网络主机地址都是233.1.1.xxx的形式 因特网地址分配策略被称为无类别域间路由选择CIDR IP地址是由因特网名字和编号分配机构ICANN管理分配，而一台主机的IP地址通常由动态主机配置协议DHCP来配置。DHCP具有将一个主机连接进一个网络的网络相关方面的自动能力 管理IP地址的典型方法：网络地址转换NAT NAT能使路由器对于外部世界看起来像一个单一IP的单一设备，使路由器对外界隐藏内部网络的细节。所有离开此内部网络的报文与进入此网络的报文都有一个相同的源地址与目的地址，NAT路由器通过使用一张NAT转换表来区分内部网络中的各个主机，转换表包含端口号与其IP地址。NAT转换表与某台主机中端口号与进程ID对照表类似。 NAT虽然得到广泛应用，但很多人反对NAT，原因如下： 1.端口号是用于进程编址，而不是主机编址 2.路由器通常仅应当处理高达第三层的分组 3.主机应彼此直接对话，结点不应该介入修改IP地址与端口号 4.应该使用IPv6来解决IP地址不足的问题 NAT的另一个问题是妨碍了P2P应用程序， 使得在某个NAT下的主机无法与另一个主机建立对等方发起的一条TCP连接。 UPnP：允许外部主机使用TCP或UDP向NAT化的主机发起通信会话。 IP地址路由过程1、当IP数据包到达主机所在局域网的路由器后，路由器会根据包头查看目的IP地址。 2、路由器拿着目的IP地址和自己的路由表分析是否在同一网络中。 3、如果在同一网络中，则将该IP数据包进行广播，如果没有则将IP数据包发送给网关，有网关分析处理进行发送。 IP地址和MAC地址IP地址和MAC地址的区别IP地址：全局唯一性，使用软件来实现网络中地址管理 MAC地址：本地唯一性，使用硬件实现 有了IP地址为什么还要MAC地址1、IP地址一般情况下容易修改和变动，具有随意性，不能再网络上固定标识一台设备。 2、MAC地址一般情况出厂时有厂家烧录到网卡中，不容易被修改，在局域范围内容易唯一定位一台设备。 3、从拓扑结构和分层上分析，IP地址属于网络层，主要功能在广域网范围内路由寻址，选择醉解路由，而MAC地址在数据链路层，要形成适合于网络媒体上传输的数据帧。","link":"/2020/04/23/network-layer/"},{"title":"Elasticsearch的使用","text":"用数据库可以实现搜索功能，为什么还需要Elasticsearch呢？在使用数据库搜索时，我们更多的是基于精确匹配的搜索，并不支持相关性匹配，与精确匹配相比，相关性匹配更贴近人的思维方式，而Elasticsearch支持相关性匹配。搜索引擎不只是搜索，还有分析，分析数据的能力，是建立在快速的查询上的，而Elasticsearch之所以能够快速查询，是因为Elasticsearch基于倒排索引，对于文档搜索来说，倒排索引在性能和空间上都有更加明显的优势。Elastic的优势还有：支持中文分词插件。 注：Elasticsearch存储数据的方式是文档存储，把对象原原本本地放进去，取出时直接取出。 在Linux上使用docker安装Elasticsearch1、安装DockerDocker要求CentOS系统的内核版本高于3.10.查看你当前的内核版本 1uname -r 若内核版本较低，可升级内核 1sudo yum update 安装Docker 1yum install docker 设置Docker为开机启动 1systemctl enable docker 启动Docker 1systemctl start docker 2、在Docker上部署Elasticsearch2.1、安装Elasticsearch下载Elasticsearch镜像 1docker pull elasticsearch 查看镜像 1docker images 运行Elasticsearch镜像 1docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -d -p 9200:9200 -p 9300:9300 --name containerName imageId 查看正在运行的容器 1docker ps 在浏览器中打开http://服务器IP地址:9200,如果看到以下信息则说明安装成功 1234567891011121314151617{ \"name\" : \"530dd7820315\", \"cluster_name\" : \"docker-cluster\", \"cluster_uuid\" : \"7O0fjpBJTkmn_axwmZX0RQ\", \"version\" : { \"number\" : \"7.2.0\", \"build_flavor\" : \"default\", \"build_type\" : \"docker\", \"build_hash\" : \"508c38a\", \"build_date\" : \"2019-06-20T15:54:18.811730Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.0.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\"} 2.2、修改配置，解决跨域访问问题首先进入到容器中，然后进入到指定目录修改elasticsearch.yml文件。 123docker exec -it elasticsearch /bin/bashcd /usr/share/elasticsearch/config/vi elasticsearch.yml 在elasticsearch.yml的文件末尾加上 12http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 修改配置后重启容器即可 1docker restart elasticsearch 2.3、安装ik分词器es自带的分词器对中文分词不是很友好，所以我们下载开源的IK分词器来解决这个问题。首先进入到plugins目录中下载分词器，下载完成后然后解压，在重启es即可 1234cd /usr/share/elasticsearch/plugins/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.2.0/elasticsearch-analysis-ik-7.2.0.zipexitdocker restart elasticsearch 注意：elasticsearch的版本和ik分词器的版本需要保持一致，不然在重启时会失败。可以在这查看所有版本，选择适合自己版本的右键复制链接地址即可。点击这里 3、用Docker安装kibana安装kibana 1docker pull kibana 启动kibana 12docker run --name kibana --link=elasticsearch:test -p 5601:5601 -d kibana:7.2.0docker start kibana 启动之后可以打开浏览器输入http://服务器IP地址:5601可以打开kibana的界面。","link":"/2020/04/04/Elasticsearch/"},{"title":"API文档生成工具Swagger2的使用","text":"在前后端分离的开发模式下，前后端系统通过接口进行交互，API接口文档变成了前后端开发人员联系的纽带，变得越来越重要，因此许多的API接口文档自动生成工具开始进入我们的视野。Swagger2是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务。它能够实时同步api与文档，但它的代码侵入性比较强，会影响正常代码阅读。 SpringBoot集成Swagger21、在pom.xml中添加依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 2、Swagger2配置类12345678910111213141516171819202122@Configuration@EnableSwagger2public class Swagger2Config{ @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.jenson.ecommerce\")) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"标题\") .description(\"相关描述\") .contact(new Contact(\"name\",\"url\",\"email\")) .version(\"1.0\") .build(); }} 3、在开发中使用相关注解(1)@Api使用在Controller层Api类上，主要属性有tags(标签)、hidden(是否隐藏)、value、authorizations等。 (2)@ApiOperation使用在Api类的接口方法上，主要属性有value(接口名称)、notes(注释)、hidden(是否隐藏)、httpMethod、ignoreJsonView、response、responseHeaders等等，某些属性注解可自动识别，无需配置。 (3)@ApiImplicitParams、@ApiImplicitParam使用在Api类的接口方法上，对接口参数进行说明，@ApiImplicitParams只有一个属性value，@ApiImplicitParam主要属性有name(参数名称)、value(参数说明)、required(是否必需)、dataType(数据类型)、paramType(参数类型)、dataTypeClass、defaultValue、readOnly等。 (4)@ApiModel用在实体类上，主要属性有description(描述)、parent(父类)、subTypes、value、discriminator等。 (5)@ApiModelProperty用在实体类属性上，主要属性有access、accessMode、allowableValues、allowEmptyValue(是否允许为空)、dataType(数据类型)、example(示例)、hidden(是否隐藏)、name(名称)、notes、required(是否必需)、value(说明)等。 注意：要保证实体类属性都有相应的get、set方法，否则swagger-ui页面无该属性说明。 4、打开swagger-ui界面运行项目后，登录localhost:项目端口号/swagger-ui.html。","link":"/2020/04/03/swagger2/"},{"title":"TCP&amp;UDP","text":"根据因特网协议栈的划分，网络体系结构可以被分为五层：物理层、链路层、网络层、运输层和应用层。 一、网络体系结构1、应用层 作用：应用层是网络应用程序及他们的应用层协议存留的地方。 主要协议：HTTP，SMTP，Telnet和FTP。 交换信息的分组：报文。 2、运输层 作用：在应用程序端点之间传送应用层报文。 主要协议：TCP和UDP。 交换信息的分组：报文段。 3、网络层 作用：将网络层分组从一台主机移动到另一台主机。 主要协议：IP协议和路由选择协议。 交换信息的分组：数据报。 4、链路层 作用：网络层必须依靠链路层的服务。特别是在每个结点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个结点。在下个结点，链路层将数据报上传给网络层。 主要协议：以太网、WiFi和电缆接入网的DOCSIS协议。 交换信息的分组：帧。 5、物理层虽然链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将该帧中的一个一个比特从一个结点移动到下一个结点。在这层中的协议仍然是链路相关的，并且进一步与该链路的实际传输媒体相关。 接下来主要介绍两个具有代表性的运输层协议–TCP和UDP。 二、UDPUDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。 它有以下几个特点： 1、面向无连接 首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。 具体来说就是： 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作2、有单播，多播，广播的功能 UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。 3、UDP是面向报文的 发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文 4、不可靠性 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。 并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。 再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。 5、头部开销小，传输数据报文时是很高效的。 UDP 头部包含了以下几个数据： 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。 三、TCP当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。 TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。 1、TCP连接过程如下图所示，可以看到建立一个TCP连接的过程为（三次握手的过程）: 第一次握手 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。 第二次握手 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。 第三次握手 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。 这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。 2、TCP断开链接TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。 第一次握手 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。 第二次握手 B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。 第三次握手 B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。 第四次握手 A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。 3、TCP协议的特点 面向连接 面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。 仅支持单播传输 每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。 面向字节流 TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。 可靠传输 对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。 提供拥塞控制 当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。 TCP提供全双工通信 TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS） 四、TCP和UDP的比较1、对比 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，使用流量控制和拥塞控制 连接个数 支持一对一，一对多，多对一和多对多交互通信 只能是一对一通信 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅8字节 首部最小20字节，最大60字节 适用场景 适用于实时应用（IP电话，视频会议，直播等） 适用于要求可靠传输的应用 2、总结 TCP向上层提供面向连接的可靠服务，UDP向上层提供无连接不可靠服务。 虽然UDP并没有TCP传输来的准确，但是也能在很多实时性要求高的地方有所作为。 对数据准确性要求高，速度可以相对较慢的，可以选用TCP。","link":"/2020/04/20/TCP-UDP/"},{"title":"Java基础知识点","text":"Java基础1、Java面向对象编程的三大特性：封装、继承、多态注意：继承时父类中的私有属性和方法，子类无法访问，只是拥有。 2、String、StringBuffer和StringBuilder的区别是什么？ 可变性String类中使用final关键字修饰字符数组来保存字符串，所以String对象是不可变的。StringBuffer和StringBuilder都继承自AbstactStringBuilder类，也是使用字符数组保存字符串，但是没有用final关键字修饰，所以这两种对象是可变的。 线程安全性String中的对象是不可变的，可以理解为常量，线程安全。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。 性能每次对String类型进行改变时，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder相比使用StringBuffer仅能获得10%~15%左右的性能提升，但要冒多线程不安全的风险。 3、在一个静态方法内调用一个非静态成员为什么是非法的？由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。 4、接口与抽象类的区别？接口的方法默认是public（Java9开始允许定义私有方法），所有方法在接口中不能有实现（Java8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。 5、==与equals==：基本数据类型比较的是值，引用数据类型比较的是内存地址。equals()：(1)类没有覆盖equals()方法。则比较的是内存地址。(2)类覆盖了equals()方法，比较的是内容是否相等，注意：String中的equals方法是被重写过的，比较的是对象的值。当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。 6、既然有了字节流，为什么还要有字符流？不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那么为什么I/O流操作要分为字节流操作和字符流操作呢？字符流是由Java虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以，I/O流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。 7、BIO，NIO，AIO有什么区别？ BIO：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，在面对十万甚至百万级连接时，传统的BIO模型是无能为力的。 NIO：NIO是一种同步非阻塞的I/O模型，在Java1.4中引入NIO框架，对应java.nio包，提供了Channel，Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式，阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性，对于高负载、高并发的(网络)应用，应使用NIO的非阻塞模式来开发 AIO：AIO也就是NIO2。在Java7中引入了NIO的改进版NIO2，它是异步非阻塞的IO模型。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在哪里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO是异步IO的错写，虽然NIO在网络操作中，提供了非阻塞的方法，但NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好是，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。目前AIO的应用还不是很广泛。 Java集合1、List,Set,Map的区别？List：不唯一，有序Set：唯一，无序Map：使用键值对存储，Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以任何对象。 2、ArrayList与LinkedList的区别？线程安全：ArrayList和LinkedList都是不同步的，也就是不保证线程安全；底层数据结构：ArrayList底层使用的是Object数组，LinkedList底层使用的是双向链表；增删数据：LinkedList插入与删除比ArrayList方便；数据快速随机访问：ArrayList支持快速随机访问，LinkedList不支持；（RandomAccess接口作为一个标识，标识实现这个接口的类具有随机访问功能）内存控件占用：ArrayList的空间浪费主要体现在List列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间。 3、ArrayList和Vector的区别？Vector类的所有方法都是同步的，可以有两个线程安全地访问一个Vector对象，但是一个线程访问Vector的话，代码要在同步操作上耗费大量的时间；ArrayList不是同步的，所以不需要保证线程安全时建议使用ArrayList。 4、HashMap和HashTable的区别？ 线程安全：HashMap是非线程安全的，如果需要满足线程安全，可以用Collections的synchronizedMap方法是HashMap具有线程安全的能力，或者使用ConcurrentHashMap；HashTable是线程安全的，HashTable内部的方法基本都经过synchronized修饰。 效率：因为线程安全的问题，HashMap要比HashTable效率高一点。另外，HashTable基本被淘汰，不要再代码中使用它。 对Null key和Null value的支持：HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为null。但是在HashTable中put进的键值只要有一个null，直接抛出NullPointerException。 初始容量大小和每次扩充容量大小的不同：创建时如果不指定容量初始值，HashTable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16，之后每次扩充，容量变为原来的2倍。创建时如果给定了容量初始值，那么HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小（HashMap中的tableSizeFor（）方法保证，下面给出了源代码）。也就是说HashMap总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。 底层数据结构：JDK1.8以后的HashMap在解决哈希表冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。HashTable没有这样的机制。 5、HashMap和HashSet的区别？HashMap：实现了Map接口，存储键值对，调用put()向map中添加元素，HashMap使用键（Key）计算Hashcode;HashSet:实现Set接口，仅存储对象，调用add()方法向Set中添加元素，HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性。 6、HashMap的底层实现JDK1.8之前HashMap底层是数组和链表结合在一起使用也就是链表散列。HashMap通过key的HashCode经过扰动函数处理过后得到hash值，然后通过（n-1)&amp;hash判断当前元素存放的位置（这里的n指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲入。所谓扰动函数指的就是HashMap的hash方法。使用hash方法也就是扰动函数是为了防止一些实现比较差的hashCode（）方法换句话说使用扰动函数之后可以减少碰撞。所谓“拉链法”就是：将链表和数组相结合，也就是说创建一个链表数组，数组中每一个就是一个链表，若遇到哈希冲突，则将冲突的指加到链表中即可。（解决哈希冲突）TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树，红黑数就是为了解决二叉查找数的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。 7、comparable和Comparator的区别？comparable接口实际上是出自java.lang包，它有一个compareTo(Object obj)方法用来排序comparator接口实际上是出自java.util包，它有一个compare(Object obj1,Object obj2)方法用来排序一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个Comparator来分别实现两种排序 8、为什么要有hashCode（散列码）?我们先以“HashSet如何检查重复”为例子来说明为什么要有hashCode：当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同HashSet就不会让其加入操作成功，如果不同的话，就会重新散列到其他位置，这样我们就大大减少了equals的次数，相应就大大提高了执行速度。 9、为什么Java中只有值传递？按值调用表示方法接受的是调用者提供的值，而按引用调用表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。Java程序设计语言总是采用按值调用，也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。 10、如何选用集合？需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap，不需要排序时就选择HashMap，需要保证线程安全就选用ConcurrentHashMap，当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。 多线程1、何为线程？线程是比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间切换工作时，负担要比进程小得多，因此，线程也被成为轻量级进程。Java程序天生就是多线程程序，我们可以通过JMX来看一下一个普通的Java程序有哪些线程，代码如下： 123456789101112public class MultiThread{ public static void main(String[] args){ //获取Java线程管理MXBean ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean(); //不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息 ThreadInfo[] threadInfo = threadMXBean.dumpAllThreads(false,false); //遍历线程信息，仅打印线程ID和线程名称信息 for(ThreadInfo threadInfo:threadInfos){ System.out.println(\"[\"+threadInfo.getThreadId()+\"]\"+threadInfo.getThreadName()); } }} 上述程序输出如下：[5] Attach Listener //添加事件[4] Signal Dispatcher //分发处理给JVM信号的线程[3] Finalizer //调用对象finalize方法的线程[2] Reference Handler //清除reference线程[1] main //main线程，程序入口从上面的输出内容可以看出：一个Java程序的运行是main线程和多个其他线程同时运行。 2、产生线程死锁须具备的四个条件 互斥条件：该资源任意一个时刻只由一个线程占用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的线程保持不放。 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才能释放资源。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 注：避免线程死锁只要破坏产生死锁的四个条件之一即可。 3、sleep()方法和wait()方法的区别和共同点？ 两者最主要的区别在于：sleep方法没有释放锁，而wait方法释放了锁。 wait()通常被用于线程间交互/通信，sleep通常被用于暂停执行。 wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。 两者都可以暂停线程的执行。 4、为什么调用start()时会执行run()方法，为什么不能直接调用run()方法？new一个Thread，线程就进入了新建状态；调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。而直接执行run()方法，会把run()方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。 5、synchronized关键字synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能由一个线程执行。 synchronized关键字最主要的三种使用方式： 修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。 修饰静态方法：也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成愿（static表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态synchronized方法，而线程B需要调用这个实例对象所属类的静态synchronized方法，是允许的，不会发生互斥现象，因为访问静态synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例对象锁。 修饰代码快：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。","link":"/2020/04/07/summary/"},{"title":"Spring MVC回顾","text":"Spring框架提供了构建Web应用程序的全功能MVC模块–Spring MVC。Spring MVC框架提供了一个DispatcherServlet作用前端控制器来分派请求，同时提供灵活的配置处理程序映射、视图解析、语言环境和主题解析，并支持文件上传。Spring MVC还包含多种视图技术。Spring MVC分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。 Spring MVC的特点 Spring MVC拥有强大的灵活性、非侵入性和可配置性。 Spring MVC提供了一个前端控制器DispatcherServlet，开发者无须额外开发控制器对象。 Spring MVC分工明确，包括控制器、验证器、命令对象、模型对象、处理程序映射视图解析器等等，每一个功能实现由一个专门的对象负责完成。 Spring MVC可以自动绑定用户输入，并正确地转换数据类型。例如，Spring MVC能自动解析字符串，并将其设置为模型的int或float类型的属性。 Spring MVC使用一个名称/值的Map对象实现更加灵活的模型数据传输。 Spring MVC内置了常见的校验器，可以校验用户输入，如果校验不通过，则重定向回输入表单。输入校验是可选的，并且支持编程方式及声明方式。 Spring MVC支持国际化，支持根据用户区域显示多国语言。 一个简单的Spring MVC应用1、引入maven依赖1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、配置DispatcherServlet许多的MVC框架中，都包含一个用于调度控制的Servlet。Spring MVC也提供了一个前端控制器DispatcherServlet，所有的请求驱动都围绕这个DispatcherServlet来分派请求。DispatcherServlet是一个Servlet(它继承自HttpServlet基类)，因此使用时需要把它配置在Web应用的部署描述符web.xml文件当中，配置信息如下： 123456789101112131415161718192021&lt;servlet&gt; &lt;!--Servlet的名称--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--Servlet对应的java类--&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--当前Servlet的参数信息--&gt; &lt;init-param&gt; &lt;!--contextConfigLocation是参数名称，该参数的值包含Spring MVC的配置文件路径--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--在Web应用启动时立即加载Servlet--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!--Servlet映射声明--&gt;&lt;servlet-mapping&gt; &lt;!--请求对应的Servlet的名称--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--监听当前域的所有请求--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置了一个DispatcherServlet，该Servlet在Web应用程序启动时立即加载，DispatcherServlet加载时会需要一个Spring MVC的配置文件，默认情况下，应用会去应用程序文件夹的WEB-INF下查找对应的[servlet-name]-servlet.xml文件，例如本例的是springmvc，默认查找的就是/WEB-INF/springmvc-servlet.xml。本例中通过init-param元素的描述，将查找的Spring MVC配置文件位置修改为/WEB-INF/springmvc-config.xml，解析该文件内容并根据文件配置信息创建一个WebApplicationContext容器对象，也称为上下文环境。WebApplication继承自ApplicationContext容器，它的初始化方式和BeanFactory、ApplicationContext有所区别，因为WebApplicationContext需要ServletContext实例，它必须在拥有Web容器的前提下才能完成启动Spring Web应用上下文的工作。 3、Controller类的实现12345678910111213141516171819202122package com.jenson.controller;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class HelloController{ private static final Log logger = LogFactory.getLog(HelloController.class); @RequestMapping(value=\"/hello\") public ModelAndView hello(){ logger.info(\"hello方法被调用\"); //创建准备返回的ModelAndView对象，该对象通常包含了返回视图名、模型的名称以及模型对象 ModelAndView mv = new ModelAndView(); //添加模型数据，可以是任意的POJO对象 mv.setViewName(\"/WEB-INF/content/welcome.jsp\"); //返回ModelAndView对象 return mv; }} 4、配置Spring MVC的Controller本例的配置文件位置在/WEB-INF/springmvc-config.xml。 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\"&gt; &lt;!--配置Handle，映射“/hello”请求--&gt; &lt;bean name=\"/hello\" class=\"com.jenson.controller.HelloController\"/&gt; &lt;!--处理映射器将bean的name作为url进行查找，需要在配置Handle时指定name(即url)--&gt; &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; &lt;!--SimpleControllerHandlerAdapter是一个处理器适配器，所有处理适配器都要实现HandlerAdapter接口--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; &lt;!--视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"/&gt;&lt;/beans&gt; 5、View页面该应用包含一个视图页面welcome.jsp，用来显示欢迎信息。 12345678910111213&lt;%@page language=\"java\" contentType=\"text/html;charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt;&lt;title&gt;welcome&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 页面可以访问Controller传递出来的message --&gt;${requestScope.message}&lt;/body&gt;&lt;/html&gt; 详解DispatcherServlet在一个Spring MVC应用运行过程中，前端控制器DispatcherServlet具体的作用是什么呢？分析DispatcherServlet源代码如下： 1234567891011protected void initStrategies(ApplicationContext context){ initMultipartResolver(context); //初始化上传文件解析器 initLocaleResolver(context); //初始化本地化解析器 initThemeResolver(context); //初始化主题解析器 initHandlerMappings(context); //初始化处理器映射器，将请求映射到处理器 initHandlerAdapters(context); //初始化处理器适配器 initHandlerExceptionResolvers(context); //初始化处理器异常解析器，如果执行过程中遇到异常将交给HandlerExceptionResolver来解析 initRequestToViewNameTranslator(context); //初始化请求到视图名称解析器 initViewResolvers(context); //初始化视图解析器，通过ViewResolver解析逻辑视图名到具体视图实现 initFlashMapManager(context); //初始化flash映射管理器} initStrategies方法将在WebApplicationContext初始化后自动执行，自动扫描上下文的Bean，根据名称或类型匹配的机制查找自定义组件，如果没有找到则会装配一套Spring的默认组件。","link":"/2020/04/07/springmvc/"},{"title":"vue中的数据双向绑定","text":"前言什么是双向数据绑定？当数据发生变化时，视图也会随之发生变化，当视图发生变化时，数据也会随着视图同步变化。数据双向绑定时对于UI控件来说的，非UI控件不会涉及到数据双向绑定。 全局性数据流使用单向，方便跟踪；局部性数据流使用双向，简单易操作。 实现数据双向绑定Vue提供了v-model指令实现数据双向绑定功能 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;h4&gt;{{msg}}&lt;/h4&gt; &lt;!--v-bind只能实现数据的单项绑定，从M自动绑定到V，无法实现数据的双向绑定--&gt; &lt;!-- &lt;input type=\"text\" v-bind:value=\"msg\" style=\"width:100%\"&gt;--&gt; &lt;input type=\"text\" style=\"width:100%\" v-model=\"msg\"&gt;&lt;/div&gt;&lt;script&gt; //创建Vue实例，得到ViewModel var vm=new Vue({ el: '#app', data: { msg: 'helloworld' }, methods: { } });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 需要注意的是，v-model只能应用在表单元素中","link":"/2020/04/06/vue-databinding/"},{"title":"Webpack","text":"Webpack是一个现代JavaScript应用程序的静态模块打包器，当Webpack处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。 为什么要使用Webpack​ 以前的前端，很多静态资源、CSS、图片和JS都是手动引入HTML页面中，杂乱无章的代码混在一个文件中，想要寻找某个功能的代码很是困难，要是分开多个文件引入，又会造成HTTP请求数过多的问题。 ​ 为了解决这个问题，出现了许多模块化工具，其中，Webpack具有模块化和组件化的特性，它将一个项目看做一个整体，简化了开发的复杂度，提高了我们的开发效率。 除此之外，Webpack在资源处理方面具有一定优势，它通过代码拆分来做资源异步加载，会消除对未引用资源的依赖，能够控制资源的处理方式，从而加快处理速度。 Webpack的使用初步了解了Webpack的优势后，接着了解如何使用Webpack。 安装Webpack可以使用npm安装，新建一个项目，在终端中转到该项目所在位置后执行下述指令就可以完成安装。 1234//全局安装npm install -g webpack//安装到项目目录npm install --save--dev webpack 使用Webpack的准备工作1.在项目中创建一个package.json文件，这是一个标准的npm说明文件","link":"/2020/04/29/webpack/"},{"title":"vue-resource与axios","text":"Vue.js是数据驱动的，不推荐直接操作DOM。因此Vue要实现异步加载可以使用vue-resource或axios，而不需要使用jQuery的DOM选择器。Vue.js2.0版本及以后推荐axios来完成ajax请求。 vue-resourcevue-resource是Vue.js的一款插件，它可以通过XMLHttpRequest或JSONP发起请求并处理响应。也就是说，$.ajax能做的事情，vue-resource插件一样也能做到，而且vue-resource的API更为简洁。另外，vue-resource还提供了非常有用的inteceptor功能，使用inteceptor可以在请求前和请求后附加一些行为，比如使用inteceptor在ajax请求时显示loading界面。 vue-resource特点vue-resource插件具有以下特点： 体积小vue-resource非常小巧，在压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。 支持主流的浏览器和Vue.js一样，vue-resource除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。 支持Promise API和URI TemplatesPromise是ES6的特性，Promise的中文含义为“先知”，Promise对象用于异步计算。 URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。 支持拦截器拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。 拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。 vue-resource使用1、引入vue-resource 1&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/vue-resource.js&quot;&gt;&lt;/script&gt; 2、引入vue-resource后，可以基于全局的Vue对象使用http，也可以基于某个Vue实例使用http。 123456// 基于全局Vue对象使用http Vue.http.get('/someUrl', [options]).then(successCallback, errorCallback); Vue.http.post('/someUrl', [body], [options]).then(successCallback, errorCallback); // 在一个Vue实例内使用http this.$http.get('/someUrl', [options]).then(successCallback, errorCallback); this.$http.post('/someUrl', [body], [options]).then(successCallback, errorCallback); 在发送请求后，使用then方法来处理响应结果，then方法有两个参数，第一个参数是响应成功时的回调函数，第二个参数是响应失败时得回调函数。 3、then方法的回调函数也有两种写法，第一种是传统的函数写法，第二种是更为简洁的ES 6的Lambda写法： 123456789101112// 传统写法 this.$http.get('/someUrl', [options]).then(function(response){ // 响应成功回调 }, function(response){ // 响应错误回调 }); // Lambda写法 this.$http.get('/someUrl', [options]).then((response) =&gt; { // 响应成功回调 }, (response) =&gt; { // 响应错误回调 }); 4、支持的HTTP方法 vue-resource的请求API是按照REST风格设计的，它提供了7种请求API： 1234567get(url, [options])head(url, [options])delete(url, [options])jsonp(url, [options])post(url, [body], [options])put(url, [body], [options])patch(url, [body], [options]) 除了jsonp以外，另外6种的API名称是标准的HTTP方法。当服务端使用REST API时，客户端的编码风格和服务端的编码风格近乎一致，这可以减少前端和后端开发人员的沟通成本。 5、emulateHTTP的作用 如果Web服务器无法处理PUT, PATCH和DELETE这种REST风格的请求，你可以启用enulateHTTP现象。启用该选项后，请求会以普通的POST方法发出，并且HTTP头信息的X-HTTP-Method-Override属性会设置为实际的HTTP方法。 1Vue.http.options.emulateHTTP = true; 6、emulateJSON的作用 如果Web服务器无法处理编码为application/json的请求，你可以启用emulateJSON选项。启用该选项后，请求会以application/x-www-form-urlencoded作为MIME type，就像普通的HTML表单一样。 Vue.http.options.emulateJSON = true; vue-resource是一个非常轻量的用于处理HTTP请求的插件，它提供了两种方式来处理HTTP请求： 使用Vue.http或this.$http 使用Vue.resource或this.$resource axios vue2.0之后，就不再对vue-resource更新，而是推荐使用axios。基于Promise的HTTP请求客户端，可同时在浏览器和Node.js中使用. 功能特性 在浏览器发送 XMLHttpRequests 请求 在 node.js 中发送 http请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换 JSON 数据 客户端支持保护安全免受 CSRF/XSRF 攻击 axios的使用 安装 axios1$ npm install axios 在要使用的文件中引入axios1import axios from 'axios' GET请求123456789101112131415161718192021// 向具有指定ID的用户发出请求axios.get('/user?ID=12345').then(function (response) {console.log(response);}).catch(function (error) {console.log(error);}); // 也可以通过 params 对象传递参数axios.get('/user', {params: {ID: 12345}}).then(function (response) {console.log(response);}).catch(function (error) {console.log(error);}); POST请求12345678910axios.post('/user', {firstName: 'Fred',lastName: 'Flintstone'}).then(function (response) {console.log(response);}).catch(function (error) {console.log(error);}); 执行多个并发请求123456789101112function getUserAccount() {return axios.get('/user/12345');} function getUserPermissions() {return axios.get('/user/12345/permissions');} axios.all([getUserAccount(), getUserPermissions()]).then(axios.spread(function (acct, perms) {//两个请求现已完成})); axios API：可以通过将相关配置传递给 axios 来进行请求。12345678910111213axios(config)// 发送一个 POST 请求axios({method: 'post',url: '/user/12345',data: {firstName: 'Fred',lastName: 'Flintstone'}});axios(url[, config])// 发送一个 GET 请求 (GET请求是默认请求模式)axios('/user/12345'); 请求方法别名： 为了方便起见，已经为所有支持的请求方法提供了别名。 1234567axios.request（config）axios.get（url [，config]）axios.delete（url [，config]）axios.head（url [，config]）axios.post（url [，data [，config]]）axios.put（url [，data [，config]]）axios.patch（url [，data [，config]]） 注意:当使用别名方法时，不需要在config中指定url，method和data属性。并发帮助函数处理并发请求。axios.all（iterable）axios.spread（callback） 创建实例也可以使用自定义配置创建axios的新实例。axios.create（[config]） 12345var instance = axios.create({baseURL: 'https://some-domain.com/api/',timeout: 1000,headers: {'X-Custom-Header': 'foobar'}}); 实例方法可用的实例方法如下所示。 指定的配置将与实例配置合并。 1234567axios＃request（config）axios＃get（url [，config]）axios＃delete（url [，config]）axios＃head（url [，config]）axios＃post（url [，data [，config]]）axios＃put（url [，data [，config]]）axios＃patch（url [，data [，config]]） 请求配置这些是用于发出请求的可用配置选项。 只有url是必需的。 如果未指定方法，请求将默认为GET。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131{// `url`是将用于请求的服务器URLurl: '/user', // `method`是发出请求时使用的请求方法method: 'get', // 默认 // `baseURL`将被添加到`url`前面，除非`url`是绝对的。// 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。baseURL: 'https://some-domain.com/api/', // `transformRequest`允许在请求数据发送到服务器之前对其进行更改// 这只适用于请求方法'PUT'，'POST'和'PATCH'// 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream transformRequest: [function (data) {// 做任何你想要的数据转换 return data;}], // `transformResponse`允许在 then / catch之前对响应数据进行更改transformResponse: [function (data) {// Do whatever you want to transform the data return data;}], // `headers`是要发送的自定义 headersheaders: {'X-Requested-With': 'XMLHttpRequest'}, // `params`是要与请求一起发送的URL参数// 必须是纯对象或URLSearchParams对象params: {ID: 12345}, // `paramsSerializer`是一个可选的函数，负责序列化`params`// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)paramsSerializer: function(params) {return Qs.stringify(params, {arrayFormat: 'brackets'})}, // `data`是要作为请求主体发送的数据// 仅适用于请求方法“PUT”，“POST”和“PATCH”// 当没有设置`transformRequest`时，必须是以下类型之一：// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams// - Browser only: FormData, File, Blob// - Node only: Streamdata: {firstName: 'Fred'}, // `timeout`指定请求超时之前的毫秒数。// 如果请求的时间超过'timeout'，请求将被中止。timeout: 1000, // `withCredentials`指示是否跨站点访问控制请求// should be made using credentialswithCredentials: false, // default // `adapter'允许自定义处理请求，这使得测试更容易。// 返回一个promise并提供一个有效的响应（参见[response docs]（＃response-api））adapter: function (config) {/* ... */}, // `auth'表示应该使用 HTTP 基本认证，并提供凭据。// 这将设置一个`Authorization'头，覆盖任何现有的`Authorization'自定义头，使用`headers`设置。auth: {username: 'janedoe',password: 's00pers3cret'}, // “responseType”表示服务器将响应的数据类型// 包括 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'responseType: 'json', // default //`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName`是携带xsrf令牌值的http头的名称xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress`允许处理上传的进度事件onUploadProgress: function (progressEvent) {// 使用本地 progress 事件做任何你想要做的}, // `onDownloadProgress`允许处理下载的进度事件onDownloadProgress: function (progressEvent) {// Do whatever you want with the native progress event}, // `maxContentLength`定义允许的http响应内容的最大大小maxContentLength: 2000, // `validateStatus`定义是否解析或拒绝给定的promise// HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被 // 拒绝。validateStatus: function (status) {return status &gt;= 200 &amp;&amp; status &lt; 300; // default}, // `maxRedirects`定义在node.js中要遵循的重定向的最大数量。// 如果设置为0，则不会遵循重定向。maxRedirects: 5, // 默认 // `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。// 允许配置类似`keepAlive`的选项，// 默认情况下不启用。httpAgent: new http.Agent({ keepAlive: true }),httpsAgent: new https.Agent({ keepAlive: true }), // 'proxy'定义代理服务器的主机名和端口// `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。// 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。proxy: {host: '127.0.0.1',port: 9000,auth: : {username: 'mikeymike',password: 'rapunz3l'}}, // “cancelToken”指定可用于取消请求的取消令牌// (see Cancellation section below for details)cancelToken: new CancelToken(function (cancel) {})} 使用 then 时，将收到如下响应： 12345678axios.get('/user/12345').then(function(response) {console.log(response.data);console.log(response.status);console.log(response.statusText);console.log(response.headers);console.log(response.config);}); 配置默认值1、全局axios默认值 123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 2、自定义实例默认值 123456//在创建实例时设置配置默认值var instance = axios.create（{ baseURL：'https://api.example.com'}）;//在实例创建后改变默认值instance.defaults.headers.common ['Authorization'] = AUTH_TOKEN; 3、配置优先级顺序配置将与优先顺序合并。 顺序是lib / defaults.js中的库默认值，然后是实例的defaults属性，最后是请求的config参数。 后者将优先于前者。 这里有一个例子。 123456789101112//使用库提供的配置默认值创建实例//此时，超时配置值为`0`，这是库的默认值var instance = axios.create（）; //覆盖库的超时默认值//现在所有请求将在超时前等待2.5秒instance.defaults.timeout = 2500; //覆盖此请求的超时，因为它知道需要很长时间instance.get('/ longRequest'，{ timeout：5000}); 拦截器你可以截取请求或响应在被 then 或者 catch 处理之前 1234567891011121314151617//添加请求拦截器axios.interceptors.request.use(function(config){ //在发送请求之前做某事 return config; }，function（error）{ //请求错误时做些事 return Promise.reject(error); }); //添加响应拦截器axios.interceptors.response.use(function(response){ //对响应数据做些事 return response; }，function(error){ //请求错误时做些事 return Promise.reject（error）; }); 如果你以后可能需要删除拦截器。 12var myInterceptor = axios.interceptors.request.use(function () {/*...*/});axios.interceptors.request.eject(myInterceptor); 你可以将拦截器添加到axios的自定义实例。 12var instance = axios.create();instance.interceptors.request.use(function () {/*...*/}); 处理错误 1234567891011121314axios.get('/ user / 12345') .catch(function(error){ if(error.response){ //请求已发出，但服务器使用状态代码进行响应 //落在2xx的范围之外 console.log（error.response.data）; console.log（error.response.status）; console.log（error.response.headers）; } else { //在设置触发错误的请求时发生了错误 console.log（'Error'，error.message）; }} console.log（error.config）; }); 您可以使用validateStatus配置选项定义自定义HTTP状态码错误范围。 12345axios.get('/ user / 12345'，{ validateStatus：function（status）{ return status &lt; 500; //仅当状态代码大于或等于500时拒绝 }}}) 消除您可以使用取消令牌取消请求。axios cancel token API基于可取消的promise提议，目前处于阶段1您可以使用CancelToken.source工厂创建一个取消令牌，如下所示： 12345678910111213141516var CancelToken = axios.CancelToken;var source = CancelToken.source（）; axios.get('/user/12345', {cancelToken: source.token}).catch(function(thrown) {if (axios.isCancel(thrown)) {console.log('Request canceled', thrown.message);} else {// 处理错误}}); //取消请求（消息参数是可选的）source.cancel（'操作被用户取消。'）; 您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌： 123456789101112var CancelToken = axios.CancelToken;var cancel; axios.get（'/ user / 12345'，{ cancelToken：new CancelToken（function executor（c）{ //一个执行器函数接收一个取消函数作为参数 cancel = c; }）}）; // 取消请求clear(); 注意：您可以使用相同的取消令牌取消几个请求。 使用application / x-www-form-urlencoded格式默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。 1、浏览器在浏览器中，您可以使用URLSearchParams API，如下所示： 1234var params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); 请注意，所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。或者，您可以使用qs库对数据进行编码： 12var qs = require('qs');axios.post('/foo', qs.stringify({ 'bar': 123 }); 2、Node.js在node.js中，可以使用querystring模块，如下所示： 12var querystring = require('querystring');axios.post('http://something.com/', querystring.stringify({ foo: 'bar' }); 3、TypeScriptaxios包括TypeScript定义。 12import axios from 'axios';axios.get('/user?ID=12345'); axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。 vue-resource和axios的区别vue-resources不再更新了，vue作者尤大推荐axios。 axios在浏览器里建立XHR通过nodejs进行http请求转换或者拦截请求数据或响应数据支持Promise的API可以取消请求自动转换JSON可以防御XSRF攻击！ vue-resources只提供了浏览器版本","link":"/2020/04/14/vue-resource/"}],"tags":[{"name":"MVVM","slug":"MVVM","link":"/tags/MVVM/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"IP协议","slug":"IP协议","link":"/tags/IP%E5%8D%8F%E8%AE%AE/"},{"name":"Elasticsearch","slug":"Elasticsearch","link":"/tags/Elasticsearch/"},{"name":"API文档自动生成工具","slug":"API文档自动生成工具","link":"/tags/API%E6%96%87%E6%A1%A3%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/"},{"name":"前后端分离","slug":"前后端分离","link":"/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"UDP","slug":"UDP","link":"/tags/UDP/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"Spring MVC","slug":"Spring-MVC","link":"/tags/Spring-MVC/"},{"name":"mvvm","slug":"mvvm","link":"/tags/mvvm/"},{"name":"数据绑定","slug":"数据绑定","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"}],"categories":[{"name":"Web前端","slug":"Web前端","link":"/categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"计算机网络基础","slug":"计算机网络基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"name":"后端开发","slug":"后端开发","link":"/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"前后端分离","slug":"前后端分离","link":"/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}]}