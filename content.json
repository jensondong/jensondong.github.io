{"pages":[{"title":"关于我","text":"","link":"/about/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"了解MVVM，从Vue实例出发","text":"MVVM的由来在过去的几年中，我们已经把很多传统的服务端代码放到了浏览器中，这样就产生了成千上万行的javascript代码，它们连接了各式各样的HTML 和CSS文件，但缺乏正规的组织形式，这也就是为什么越来越多的开发者使用javascript框架。比如：angular、react、vue。浏览器的兼容性问题已经不再是前端的阻碍。前端的项目越来越大，项目的可维护性和扩展性、安全性等成了主要问题。当年为了解决浏览器兼容性问题，出现了很多类库，其中最典型的就是jquery。但是这类库没有实现对业务逻辑的分成，所以维护性和扩展性极差。综上两方面原因，才有了MVVM模式一类框架的出现。比如vue,通过数据的双向绑定，极大了提高了开发效率。 MVVM的概述MVVM是Model-View-ViewModel的简写，它是一种前端视图层的分层开发思想，Model指的是传递的数据，View指的是页面的结构，而ViewModel是MVVM模式的核心，它是连接View和Model的桥梁，当数据变化时ViewModel能够监听到，然后使对应的视图做出自动更新，当视图变化使ViewModel也能监听到，从而使数据自动更新，这就实现了数据的双向绑定，这也是MVVM思想的好处。 采用MVVM模式的框架Vue Vue是一套用于构建用户界面的渐进式JavaScript框架，只关注视图层，方便与第三方库或既有项目整合 代码实例： 12345678910111213141516171819202122232425262728293031&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!--导入Vue的包--&gt; &lt;script src=\"./bin/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--Vue实例所控制的这个元素区域，就是我们的V--&gt; &lt;div id=\"app\"&gt; &lt;p&gt;{{msg}}&lt;/p&gt;&lt;/div&gt; &lt;script&gt; //创建一个Vue实例 //当我们导入包之后，在浏览器的内存中，就多了一个Vue构造函数 //new出来的这个vm对象，就是我们MVVM中的VM调度者 var vm = new Vue({ el: '#app', //表示当前new的这个Vue实例，要控制页面上的哪个区域 //这里的data就是MVVM中的M，专门用来存放数据 data: { //data属性中，存放的是el要用到的数据 msg: 'HelloWorld' //通过Vue提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了 } }） &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/03/30/mvvm/"},{"title":"Spring MVC回顾","text":"Spring框架提供了构建Web应用程序的全功能MVC模块–Spring MVC。Spring MVC框架提供了一个DispatcherServlet作用前端控制器来分派请求，同时提供灵活的配置处理程序映射、视图解析、语言环境和主题解析，并支持文件上传。Spring MVC还包含多种视图技术。Spring MVC分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。 Spring MVC的特点 Spring MVC拥有强大的灵活性、非侵入性和可配置性。 Spring MVC提供了一个前端控制器DispatcherServlet，开发者无须额外开发控制器对象。 Spring MVC分工明确，包括控制器、验证器、命令对象、模型对象、处理程序映射视图解析器等等，每一个功能实现由一个专门的对象负责完成。 Spring MVC可以自动绑定用户输入，并正确地转换数据类型。例如，Spring MVC能自动解析字符串，并将其设置为模型的int或float类型的属性。 Spring MVC使用一个名称/值的Map对象实现更加灵活的模型数据传输。 Spring MVC内置了常见的校验器，可以校验用户输入，如果校验不通过，则重定向回输入表单。输入校验是可选的，并且支持编程方式及声明方式。 Spring MVC支持国际化，支持根据用户区域显示多国语言。 一个简单的Spring MVC应用1、引入maven依赖1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、配置DispatcherServlet许多的MVC框架中，都包含一个用于调度控制的Servlet。Spring MVC也提供了一个前端控制器DispatcherServlet，所有的请求驱动都围绕这个DispatcherServlet来分派请求。DispatcherServlet是一个Servlet(它继承自HttpServlet基类)，因此使用时需要把它配置在Web应用的部署描述符web.xml文件当中，配置信息如下： 123456789101112131415161718192021&lt;servlet&gt; &lt;!--Servlet的名称--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--Servlet对应的java类--&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--当前Servlet的参数信息--&gt; &lt;init-param&gt; &lt;!--contextConfigLocation是参数名称，该参数的值包含Spring MVC的配置文件路径--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--在Web应用启动时立即加载Servlet--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!--Servlet映射声明--&gt;&lt;servlet-mapping&gt; &lt;!--请求对应的Servlet的名称--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--监听当前域的所有请求--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置了一个DispatcherServlet，该Servlet在Web应用程序启动时立即加载，DispatcherServlet加载时会需要一个Spring MVC的配置文件，默认情况下，应用会去应用程序文件夹的WEB-INF下查找对应的[servlet-name]-servlet.xml文件，例如本例的是springmvc，默认查找的就是/WEB-INF/springmvc-servlet.xml。本例中通过init-param元素的描述，将查找的Spring MVC配置文件位置修改为/WEB-INF/springmvc-config.xml，解析该文件内容并根据文件配置信息创建一个WebApplicationContext容器对象，也称为上下文环境。WebApplication继承自ApplicationContext容器，它的初始化方式和BeanFactory、ApplicationContext有所区别，因为WebApplicationContext需要ServletContext实例，它必须在拥有Web容器的前提下才能完成启动Spring Web应用上下文的工作。 3、Controller类的实现12345678910111213141516171819202122package com.jenson.controller;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class HelloController{ private static final Log logger = LogFactory.getLog(HelloController.class); @RequestMapping(value=\"/hello\") public ModelAndView hello(){ logger.info(\"hello方法被调用\"); //创建准备返回的ModelAndView对象，该对象通常包含了返回视图名、模型的名称以及模型对象 ModelAndView mv = new ModelAndView(); //添加模型数据，可以是任意的POJO对象 mv.setViewName(\"/WEB-INF/content/welcome.jsp\"); //返回ModelAndView对象 return mv; }} 4、配置Spring MVC的Controller本例的配置文件位置在/WEB-INF/springmvc-config.xml。 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\"&gt; &lt;!--配置Handle，映射“/hello”请求--&gt; &lt;bean name=\"/hello\" class=\"com.jenson.controller.HelloController\"/&gt; &lt;!--处理映射器将bean的name作为url进行查找，需要在配置Handle时指定name(即url)--&gt; &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; &lt;!--SimpleControllerHandlerAdapter是一个处理器适配器，所有处理适配器都要实现HandlerAdapter接口--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; &lt;!--视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"/&gt;&lt;/beans&gt; 5、View页面该应用包含一个视图页面welcome.jsp，用来显示欢迎信息。 12345678910111213&lt;%@page language=\"java\" contentType=\"text/html;charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt;&lt;title&gt;welcome&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 页面可以访问Controller传递出来的message --&gt;${requestScope.message}&lt;/body&gt;&lt;/html&gt; 详解DispatcherServlet在一个Spring MVC应用运行过程中，前端控制器DispatcherServlet具体的作用是什么呢？分析DispatcherServlet源代码如下： 1234567891011protected void initStrategies(ApplicationContext context){ initMultipartResolver(context); //初始化上传文件解析器 initLocaleResolver(context); //初始化本地化解析器 initThemeResolver(context); //初始化主题解析器 initHandlerMappings(context); //初始化处理器映射器，将请求映射到处理器 initHandlerAdapters(context); //初始化处理器适配器 initHandlerExceptionResolvers(context); //初始化处理器异常解析器，如果执行过程中遇到异常将交给HandlerExceptionResolver来解析 initRequestToViewNameTranslator(context); //初始化请求到视图名称解析器 initViewResolvers(context); //初始化视图解析器，通过ViewResolver解析逻辑视图名到具体视图实现 initFlashMapManager(context); //初始化flash映射管理器} initStrategies方法将在WebApplicationContext初始化后自动执行，自动扫描上下文的Bean，根据名称或类型匹配的机制查找自定义组件，如果没有找到则会装配一套Spring的默认组件。","link":"/2020/04/07/springmvc/"},{"title":"Java基础知识点","text":"Java基础1、Java面向对象编程的三大特性：封装、继承、多态注意：继承时父类中的私有属性和方法，子类无法访问，只是拥有。 2、String、StringBuffer和StringBuilder的区别是什么？ 可变性String类中使用final关键字修饰字符数组来保存字符串，所以String对象是不可变的。StringBuffer和StringBuilder都继承自AbstactStringBuilder类，也是使用字符数组保存字符串，但是没有用final关键字修饰，所以这两种对象是可变的。 线程安全性String中的对象是不可变的，可以理解为常量，线程安全。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。 性能每次对String类型进行改变时，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder相比使用StringBuffer仅能获得10%~15%左右的性能提升，但要冒多线程不安全的风险。3、在一个静态方法内调用一个非静态成员为什么是非法的？由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。4、接口与抽象类的区别？接口的方法默认是public（Java9开始允许定义私有方法），所有方法在接口中不能有实现（Java8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。5、==与equals==：基本数据类型比较的是值，引用数据类型比较的是内存地址。equals()：(1)类没有覆盖equals()方法。则比较的是内存地址。(2)类覆盖了equals()方法，比较的是内容是否相等，注意：String中的equals方法是被重写过的，比较的是对象的值。当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。6、既然有了字节流，为什么还要有字符流？不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那么为什么I/O流操作要分为字节流操作和字符流操作呢？字符流是由Java虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以，I/O流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。7、BIO，NIO，AIO有什么区别？ BIO：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，在面对十万甚至百万级连接时，传统的BIO模型是无能为力的。 NIO：NIO是一种同步非阻塞的I/O模型，在Java1.4中引入NIO框架，对应java.nio包，提供了Channel，Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式，阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性，对于高负载、高并发的(网络)应用，应使用NIO的非阻塞模式来开发 AIO：AIO也就是NIO2。在Java7中引入了NIO的改进版NIO2，它是异步非阻塞的IO模型。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在哪里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO是异步IO的错写，虽然NIO在网络操作中，提供了非阻塞的方法，但NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好是，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。目前AIO的应用还不是很广泛。Java集合1、List,Set,Map的区别？List：不唯一，有序Set：唯一，无序Map：使用键值对存储，Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以任何对象。2、ArrayList与LinkedList的区别？线程安全：ArrayList和LinkedList都是不同步的，也就是不保证线程安全；底层数据结构：ArrayList底层使用的是Object数组，LinkedList底层使用的是双向链表；增删数据：LinkedList插入与删除比ArrayList方便；数据快速随机访问：ArrayList支持快速随机访问，LinkedList不支持；（RandomAccess接口作为一个标识，标识实现这个接口的类具有随机访问功能）内存控件占用：ArrayList的空间浪费主要体现在List列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间。3、ArrayList和Vector的区别？Vector类的所有方法都是同步的，可以有两个线程安全地访问一个Vector对象，但是一个线程访问Vector的话，代码要在同步操作上耗费大量的时间；ArrayList不是同步的，所以不需要保证线程安全时建议使用ArrayList。4、HashMap和HashTable的区别 线程安全：HashMap是非线程安全的，如果需要满足线程安全，可以用Collections的synchronizedMap方法是HashMap具有线程安全的能力，或者使用ConcurrentHashMap；HashTable是线程安全的，HashTable内部的方法基本都经过synchronized修饰。 效率：因为线程安全的问题，HashMap要比HashTable效率高一点。另外，HashTable基本被淘汰，不要再代码中使用它。 对Null key和Null value的支持：HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为null。但是在HashTable中put进的键值只要有一个null，直接抛出NullPointerException。 初始容量大小和每次扩充容量大小的不同：创建时如果不指定容量初始值，HashTable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16，之后每次扩充，容量变为原来的2倍。创建时如果给定了容量初始值，那么HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小（HashMap中的tableSizeFor（）方法保证，下面给出了源代码）。也就是说HashMap总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。 底层数据结构：JDK1.8以后的HashMap在解决哈希表冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。HashTable没有这样的机制。5、HashMap和HashSet的区别？HashMap：实现了Map接口，存储键值对，调用put()向map中添加元素，HashMap使用键（Key）计算Hashcode;HashSet:实现Set接口，仅存储对象，调用add()方法向Set中添加元素，HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性。6、HashMap的底层实现JDK1.8之前HashMap底层是数组和链表结合在一起使用也就是链表散列。HashMap通过key的HashCode经过扰动函数处理过后得到hash值，然后通过（n-1)&amp;hash判断当前元素存放的位置（这里的n指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲入。所谓扰动函数指的就是HashMap的hash方法。使用hash方法也就是扰动函数是为了防止一些实现比较差的hashCode（）方法换句话说使用扰动函数之后可以减少碰撞。所谓“拉链法”就是：将链表和数组相结合，也就是说创建一个链表数组，数组中每一个就是一个链表，若遇到哈希冲突，则将冲突的指加到链表中即可。（解决哈希冲突）TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树，红黑数就是为了解决二叉查找数的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。7、comparable和Comparator的区别？comparable接口实际上是出自java.lang包，它有一个compareTo(Object obj)方法用来排序comparator接口实际上是出自java.util包，它有一个compare(Object obj1,Object obj2)方法用来排序一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个Comparator来分别实现两种排序8、为什么要有hashCode（散列码）?我们先以“HashSet如何检查重复”为例子来说明为什么要有hashCode：当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同HashSet就不会让其加入操作成功，如果不同的话，就会重新散列到其他位置，这样我们就大大减少了equals的次数，相应就大大提高了执行速度9、为什么Java中只有值传递？按值调用表示方法接受的是调用者提供的值，而按引用调用表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。Java程序设计语言总是采用按值调用，也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。10、如何选用集合？需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap，不需要排序时就选择HashMap，需要保证线程安全就选用ConcurrentHashMap，当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。多线程1、何为线程？线程是比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间切换工作时，负担要比进程小得多，因此，线程也被成为轻量级进程。Java程序天生就是多线程程序，我们可以通过JMX来看一下一个普通的Java程序有哪些线程，代码如下：123456789101112public class MultiThread{ public static void main(String[] args){ //获取Java线程管理MXBean ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean(); //不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息 ThreadInfo[] threadInfo = threadMXBean.dumpAllThreads(false,false); //遍历线程信息，仅打印线程ID和线程名称信息 for(ThreadInfo threadInfo:threadInfos){ System.out.println(\"[\"+threadInfo.getThreadId()+\"]\"+threadInfo.getThreadName()); } }} 上述程序输出如下：[5] Attach Listener //添加事件[4] Signal Dispatcher //分发处理给JVM信号的线程[3] Finalizer //调用对象finalize方法的线程[2] Reference Handler //清除reference线程[1] main //main线程，程序入口从上面的输出内容可以看出：一个Java程序的运行是main线程和多个其他线程同时运行。","link":"/2020/04/07/summary/"},{"title":"API文档生成工具Swagger2的使用","text":"在前后端分离的开发模式下，前后端系统通过接口进行交互，API接口文档变成了前后端开发人员联系的纽带，变得越来越重要，因此许多的API接口文档自动生成工具开始进入我们的视野。Swagger2是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务。它能够实时同步api与文档，但它的代码侵入性比较强，会影响正常代码阅读。 SpringBoot集成Swagger21、在pom.xml中添加依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 2、Swagger2配置类12345678910111213141516171819202122@Configuration@EnableSwagger2public class Swagger2Config{ @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.jenson.ecommerce\")) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"标题\") .description(\"相关描述\") .contact(new Contact(\"name\",\"url\",\"email\")) .version(\"1.0\") .build(); }} 3、在开发中使用相关注解(1)@Api使用在Controller层Api类上，主要属性有tags(标签)、hidden(是否隐藏)、value、authorizations等。 (2)@ApiOperation使用在Api类的接口方法上，主要属性有value(接口名称)、notes(注释)、hidden(是否隐藏)、httpMethod、ignoreJsonView、response、responseHeaders等等，某些属性注解可自动识别，无需配置。 (3)@ApiImplicitParams、@ApiImplicitParam使用在Api类的接口方法上，对接口参数进行说明，@ApiImplicitParams只有一个属性value，@ApiImplicitParam主要属性有name(参数名称)、value(参数说明)、required(是否必需)、dataType(数据类型)、paramType(参数类型)、dataTypeClass、defaultValue、readOnly等。 (4)@ApiModel用在实体类上，主要属性有description(描述)、parent(父类)、subTypes、value、discriminator等。 (5)@ApiModelProperty用在实体类属性上，主要属性有access、accessMode、allowableValues、allowEmptyValue(是否允许为空)、dataType(数据类型)、example(示例)、hidden(是否隐藏)、name(名称)、notes、required(是否必需)、value(说明)等。 注意：要保证实体类属性都有相应的get、set方法，否则swagger-ui页面无该属性说明。 4、打开swagger-ui界面运行项目后，登录localhost:项目端口号/swagger-ui.html。","link":"/2020/04/03/swagger2/"},{"title":"Elasticsearch的使用","text":"用数据库可以实现搜索功能，为什么还需要Elasticsearch呢？在使用数据库搜索时，我们更多的是基于精确匹配的搜索，并不支持相关性匹配，与精确匹配相比，相关性匹配更贴近人的思维方式，而Elasticsearch支持相关性匹配。搜索引擎不只是搜索，还有分析，分析数据的能力，是建立在快速的查询上的，而Elasticsearch之所以能够快速查询，是因为Elasticsearch基于倒排索引，对于文档搜索来说，倒排索引在性能和空间上都有更加明显的优势。Elastic的优势还有：支持中文分词插件。 注：Elasticsearch存储数据的方式是文档存储，把对象原原本本地放进去，取出时直接取出。 在Linux上使用docker安装Elasticsearch1、安装DockerDocker要求CentOS系统的内核版本高于3.10.查看你当前的内核版本 1uname -r 若内核版本较低，可升级内核 1sudo yum update 安装Docker 1yum install docker 设置Docker为开机启动 1systemctl enable docker 启动Docker 1systemctl start docker 2、在Docker上部署Elasticsearch2.1、安装Elasticsearch下载Elasticsearch镜像 1docker pull elasticsearch 查看镜像 1docker images 运行Elasticsearch镜像 1docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -d -p 9200:9200 -p 9300:9300 --name containerName imageId 查看正在运行的容器 1docker ps 在浏览器中打开http://服务器IP地址:9200,如果看到以下信息则说明安装成功 1234567891011121314151617{ \"name\" : \"530dd7820315\", \"cluster_name\" : \"docker-cluster\", \"cluster_uuid\" : \"7O0fjpBJTkmn_axwmZX0RQ\", \"version\" : { \"number\" : \"7.2.0\", \"build_flavor\" : \"default\", \"build_type\" : \"docker\", \"build_hash\" : \"508c38a\", \"build_date\" : \"2019-06-20T15:54:18.811730Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.0.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\"} 2.2、修改配置，解决跨域访问问题首先进入到容器中，然后进入到指定目录修改elasticsearch.yml文件。 123docker exec -it elasticsearch /bin/bashcd /usr/share/elasticsearch/config/vi elasticsearch.yml 在elasticsearch.yml的文件末尾加上 12http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 修改配置后重启容器即可 1docker restart elasticsearch 2.3、安装ik分词器es自带的分词器对中文分词不是很友好，所以我们下载开源的IK分词器来解决这个问题。首先进入到plugins目录中下载分词器，下载完成后然后解压，在重启es即可 1234cd /usr/share/elasticsearch/plugins/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.2.0/elasticsearch-analysis-ik-7.2.0.zipexitdocker restart elasticsearch 注意：elasticsearch的版本和ik分词器的版本需要保持一致，不然在重启时会失败。可以在这查看所有版本，选择适合自己版本的右键复制链接地址即可。点击这里 3、用Docker安装kibana安装kibana 1docker pull kibana 启动kibana 12docker run --name kibana --link=elasticsearch:test -p 5601:5601 -d kibana:7.2.0docker start kibana 启动之后可以打开浏览器输入http://服务器IP地址:5601可以打开kibana的界面。","link":"/2020/04/04/Elasticsearch/"},{"title":"vue中的数据双向绑定","text":"前言什么是双向数据绑定？当数据发生变化时，视图也会随之发生变化，当视图发生变化时，数据也会随着视图同步变化。数据双向绑定时对于UI控件来说的，非UI控件不会涉及到数据双向绑定。 全局性数据流使用单向，方便跟踪；局部性数据流使用双向，简单易操作。 实现数据双向绑定Vue提供了v-model指令实现数据双向绑定功能 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;h4&gt;{{msg}}&lt;/h4&gt; &lt;!--v-bind只能实现数据的单项绑定，从M自动绑定到V，无法实现数据的双向绑定--&gt; &lt;!-- &lt;input type=\"text\" v-bind:value=\"msg\" style=\"width:100%\"&gt;--&gt; &lt;input type=\"text\" style=\"width:100%\" v-model=\"msg\"&gt;&lt;/div&gt;&lt;script&gt; //创建Vue实例，得到ViewModel var vm=new Vue({ el: '#app', data: { msg: 'helloworld' }, methods: { } });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 需要注意的是，v-model只能应用在表单元素中","link":"/2020/04/06/vue-databinding/"},{"title":"vue-resource与axios","text":"Vue.js是数据驱动的，不推荐直接操作DOM。因此Vue要实现异步加载可以使用vue-resource或axios，而不需要使用jQuery的DOM选择器。Vue.js2.0版本及以后推荐axios来完成ajax请求。 vue-resourcevue-resource是Vue.js的一款插件，它可以通过XMLHttpRequest或JSONP发起请求并处理响应。也就是说，$.ajax能做的事情，vue-resource插件一样也能做到，而且vue-resource的API更为简洁。另外，vue-resource还提供了非常有用的inteceptor功能，使用inteceptor可以在请求前和请求后附加一些行为，比如使用inteceptor在ajax请求时显示loading界面。 vue-resource特点vue-resource插件具有以下特点： 体积小vue-resource非常小巧，在压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。 支持主流的浏览器和Vue.js一样，vue-resource除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。 支持Promise API和URI TemplatesPromise是ES6的特性，Promise的中文含义为“先知”，Promise对象用于异步计算。 URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。 支持拦截器拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。 拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。 vue-resource使用1、引入vue-resource 1&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/vue-resource.js&quot;&gt;&lt;/script&gt; 2、引入vue-resource后，可以基于全局的Vue对象使用http，也可以基于某个Vue实例使用http。 123456// 基于全局Vue对象使用http Vue.http.get('/someUrl', [options]).then(successCallback, errorCallback); Vue.http.post('/someUrl', [body], [options]).then(successCallback, errorCallback); // 在一个Vue实例内使用http this.$http.get('/someUrl', [options]).then(successCallback, errorCallback); this.$http.post('/someUrl', [body], [options]).then(successCallback, errorCallback); 在发送请求后，使用then方法来处理响应结果，then方法有两个参数，第一个参数是响应成功时的回调函数，第二个参数是响应失败时得回调函数。 3、then方法的回调函数也有两种写法，第一种是传统的函数写法，第二种是更为简洁的ES 6的Lambda写法： 123456789101112// 传统写法 this.$http.get('/someUrl', [options]).then(function(response){ // 响应成功回调 }, function(response){ // 响应错误回调 }); // Lambda写法 this.$http.get('/someUrl', [options]).then((response) =&gt; { // 响应成功回调 }, (response) =&gt; { // 响应错误回调 }); 4、支持的HTTP方法 vue-resource的请求API是按照REST风格设计的，它提供了7种请求API： 1234567get(url, [options])head(url, [options])delete(url, [options])jsonp(url, [options])post(url, [body], [options])put(url, [body], [options])patch(url, [body], [options]) 除了jsonp以外，另外6种的API名称是标准的HTTP方法。当服务端使用REST API时，客户端的编码风格和服务端的编码风格近乎一致，这可以减少前端和后端开发人员的沟通成本。 5、emulateHTTP的作用 如果Web服务器无法处理PUT, PATCH和DELETE这种REST风格的请求，你可以启用enulateHTTP现象。启用该选项后，请求会以普通的POST方法发出，并且HTTP头信息的X-HTTP-Method-Override属性会设置为实际的HTTP方法。 1Vue.http.options.emulateHTTP = true; 6、emulateJSON的作用 如果Web服务器无法处理编码为application/json的请求，你可以启用emulateJSON选项。启用该选项后，请求会以application/x-www-form-urlencoded作为MIME type，就像普通的HTML表单一样。 Vue.http.options.emulateJSON = true; vue-resource是一个非常轻量的用于处理HTTP请求的插件，它提供了两种方式来处理HTTP请求： 使用Vue.http或this.$http 使用Vue.resource或this.$resource axios vue2.0之后，就不再对vue-resource更新，而是推荐使用axios。基于Promise的HTTP请求客户端，可同时在浏览器和Node.js中使用. 功能特性 在浏览器发送 XMLHttpRequests 请求 在 node.js 中发送 http请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换 JSON 数据 客户端支持保护安全免受 CSRF/XSRF 攻击 axios的使用 安装 axios1$ npm install axios 在要使用的文件中引入axios1import axios from 'axios' GET请求123456789101112131415161718192021// 向具有指定ID的用户发出请求axios.get('/user?ID=12345').then(function (response) {console.log(response);}).catch(function (error) {console.log(error);}); // 也可以通过 params 对象传递参数axios.get('/user', {params: {ID: 12345}}).then(function (response) {console.log(response);}).catch(function (error) {console.log(error);}); POST请求12345678910axios.post('/user', {firstName: 'Fred',lastName: 'Flintstone'}).then(function (response) {console.log(response);}).catch(function (error) {console.log(error);}); 执行多个并发请求123456789101112function getUserAccount() {return axios.get('/user/12345');} function getUserPermissions() {return axios.get('/user/12345/permissions');} axios.all([getUserAccount(), getUserPermissions()]).then(axios.spread(function (acct, perms) {//两个请求现已完成})); axios API：可以通过将相关配置传递给 axios 来进行请求。12345678910111213axios(config)// 发送一个 POST 请求axios({method: 'post',url: '/user/12345',data: {firstName: 'Fred',lastName: 'Flintstone'}});axios(url[, config])// 发送一个 GET 请求 (GET请求是默认请求模式)axios('/user/12345'); 请求方法别名： 为了方便起见，已经为所有支持的请求方法提供了别名。 1234567axios.request（config）axios.get（url [，config]）axios.delete（url [，config]）axios.head（url [，config]）axios.post（url [，data [，config]]）axios.put（url [，data [，config]]）axios.patch（url [，data [，config]]） 注意:当使用别名方法时，不需要在config中指定url，method和data属性。并发帮助函数处理并发请求。axios.all（iterable）axios.spread（callback） 创建实例也可以使用自定义配置创建axios的新实例。axios.create（[config]） 12345var instance = axios.create({baseURL: 'https://some-domain.com/api/',timeout: 1000,headers: {'X-Custom-Header': 'foobar'}}); 实例方法可用的实例方法如下所示。 指定的配置将与实例配置合并。 1234567axios＃request（config）axios＃get（url [，config]）axios＃delete（url [，config]）axios＃head（url [，config]）axios＃post（url [，data [，config]]）axios＃put（url [，data [，config]]）axios＃patch（url [，data [，config]]） 请求配置这些是用于发出请求的可用配置选项。 只有url是必需的。 如果未指定方法，请求将默认为GET。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131{// `url`是将用于请求的服务器URLurl: '/user', // `method`是发出请求时使用的请求方法method: 'get', // 默认 // `baseURL`将被添加到`url`前面，除非`url`是绝对的。// 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。baseURL: 'https://some-domain.com/api/', // `transformRequest`允许在请求数据发送到服务器之前对其进行更改// 这只适用于请求方法'PUT'，'POST'和'PATCH'// 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream transformRequest: [function (data) {// 做任何你想要的数据转换 return data;}], // `transformResponse`允许在 then / catch之前对响应数据进行更改transformResponse: [function (data) {// Do whatever you want to transform the data return data;}], // `headers`是要发送的自定义 headersheaders: {'X-Requested-With': 'XMLHttpRequest'}, // `params`是要与请求一起发送的URL参数// 必须是纯对象或URLSearchParams对象params: {ID: 12345}, // `paramsSerializer`是一个可选的函数，负责序列化`params`// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)paramsSerializer: function(params) {return Qs.stringify(params, {arrayFormat: 'brackets'})}, // `data`是要作为请求主体发送的数据// 仅适用于请求方法“PUT”，“POST”和“PATCH”// 当没有设置`transformRequest`时，必须是以下类型之一：// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams// - Browser only: FormData, File, Blob// - Node only: Streamdata: {firstName: 'Fred'}, // `timeout`指定请求超时之前的毫秒数。// 如果请求的时间超过'timeout'，请求将被中止。timeout: 1000, // `withCredentials`指示是否跨站点访问控制请求// should be made using credentialswithCredentials: false, // default // `adapter'允许自定义处理请求，这使得测试更容易。// 返回一个promise并提供一个有效的响应（参见[response docs]（＃response-api））adapter: function (config) {/* ... */}, // `auth'表示应该使用 HTTP 基本认证，并提供凭据。// 这将设置一个`Authorization'头，覆盖任何现有的`Authorization'自定义头，使用`headers`设置。auth: {username: 'janedoe',password: 's00pers3cret'}, // “responseType”表示服务器将响应的数据类型// 包括 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'responseType: 'json', // default //`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName`是携带xsrf令牌值的http头的名称xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress`允许处理上传的进度事件onUploadProgress: function (progressEvent) {// 使用本地 progress 事件做任何你想要做的}, // `onDownloadProgress`允许处理下载的进度事件onDownloadProgress: function (progressEvent) {// Do whatever you want with the native progress event}, // `maxContentLength`定义允许的http响应内容的最大大小maxContentLength: 2000, // `validateStatus`定义是否解析或拒绝给定的promise// HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被 // 拒绝。validateStatus: function (status) {return status &gt;= 200 &amp;&amp; status &lt; 300; // default}, // `maxRedirects`定义在node.js中要遵循的重定向的最大数量。// 如果设置为0，则不会遵循重定向。maxRedirects: 5, // 默认 // `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。// 允许配置类似`keepAlive`的选项，// 默认情况下不启用。httpAgent: new http.Agent({ keepAlive: true }),httpsAgent: new https.Agent({ keepAlive: true }), // 'proxy'定义代理服务器的主机名和端口// `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。// 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。proxy: {host: '127.0.0.1',port: 9000,auth: : {username: 'mikeymike',password: 'rapunz3l'}}, // “cancelToken”指定可用于取消请求的取消令牌// (see Cancellation section below for details)cancelToken: new CancelToken(function (cancel) {})} 使用 then 时，将收到如下响应： 12345678axios.get('/user/12345').then(function(response) {console.log(response.data);console.log(response.status);console.log(response.statusText);console.log(response.headers);console.log(response.config);}); 配置默认值1、全局axios默认值 123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 2、自定义实例默认值 123456//在创建实例时设置配置默认值var instance = axios.create（{ baseURL：'https://api.example.com'}）;//在实例创建后改变默认值instance.defaults.headers.common ['Authorization'] = AUTH_TOKEN; 3、配置优先级顺序配置将与优先顺序合并。 顺序是lib / defaults.js中的库默认值，然后是实例的defaults属性，最后是请求的config参数。 后者将优先于前者。 这里有一个例子。 123456789101112//使用库提供的配置默认值创建实例//此时，超时配置值为`0`，这是库的默认值var instance = axios.create（）; //覆盖库的超时默认值//现在所有请求将在超时前等待2.5秒instance.defaults.timeout = 2500; //覆盖此请求的超时，因为它知道需要很长时间instance.get('/ longRequest'，{ timeout：5000}); 拦截器你可以截取请求或响应在被 then 或者 catch 处理之前 1234567891011121314151617//添加请求拦截器axios.interceptors.request.use(function(config){ //在发送请求之前做某事 return config; }，function（error）{ //请求错误时做些事 return Promise.reject(error); }); //添加响应拦截器axios.interceptors.response.use(function(response){ //对响应数据做些事 return response; }，function(error){ //请求错误时做些事 return Promise.reject（error）; }); 如果你以后可能需要删除拦截器。 12var myInterceptor = axios.interceptors.request.use(function () {/*...*/});axios.interceptors.request.eject(myInterceptor); 你可以将拦截器添加到axios的自定义实例。 12var instance = axios.create();instance.interceptors.request.use(function () {/*...*/}); 处理错误 1234567891011121314axios.get('/ user / 12345') .catch(function(error){ if(error.response){ //请求已发出，但服务器使用状态代码进行响应 //落在2xx的范围之外 console.log（error.response.data）; console.log（error.response.status）; console.log（error.response.headers）; } else { //在设置触发错误的请求时发生了错误 console.log（'Error'，error.message）; }} console.log（error.config）; }); 您可以使用validateStatus配置选项定义自定义HTTP状态码错误范围。 12345axios.get('/ user / 12345'，{ validateStatus：function（status）{ return status &lt; 500; //仅当状态代码大于或等于500时拒绝 }}}) 消除您可以使用取消令牌取消请求。axios cancel token API基于可取消的promise提议，目前处于阶段1您可以使用CancelToken.source工厂创建一个取消令牌，如下所示： 12345678910111213141516var CancelToken = axios.CancelToken;var source = CancelToken.source（）; axios.get('/user/12345', {cancelToken: source.token}).catch(function(thrown) {if (axios.isCancel(thrown)) {console.log('Request canceled', thrown.message);} else {// 处理错误}}); //取消请求（消息参数是可选的）source.cancel（'操作被用户取消。'）; 您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌： 123456789101112var CancelToken = axios.CancelToken;var cancel; axios.get（'/ user / 12345'，{ cancelToken：new CancelToken（function executor（c）{ //一个执行器函数接收一个取消函数作为参数 cancel = c; }）}）; // 取消请求clear(); 注意：您可以使用相同的取消令牌取消几个请求。 使用application / x-www-form-urlencoded格式默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。 1、浏览器在浏览器中，您可以使用URLSearchParams API，如下所示： 1234var params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); 请注意，所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。或者，您可以使用qs库对数据进行编码： 12var qs = require('qs');axios.post('/foo', qs.stringify({ 'bar': 123 }); 2、Node.js在node.js中，可以使用querystring模块，如下所示： 12var querystring = require('querystring');axios.post('http://something.com/', querystring.stringify({ foo: 'bar' }); 3、TypeScriptaxios包括TypeScript定义。 12import axios from 'axios';axios.get('/user?ID=12345'); axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。 vue-resource和axios的区别vue-resources不再更新了，vue作者尤大推荐axios。 axios在浏览器里建立XHR通过nodejs进行http请求转换或者拦截请求数据或响应数据支持Promise的API可以取消请求自动转换JSON可以防御XSRF攻击！ vue-resources只提供了浏览器版本","link":"/2020/04/14/vue-resource/"}],"tags":[{"name":"MVVM","slug":"MVVM","link":"/tags/MVVM/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Spring MVC","slug":"Spring-MVC","link":"/tags/Spring-MVC/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"API文档自动生成工具","slug":"API文档自动生成工具","link":"/tags/API%E6%96%87%E6%A1%A3%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/"},{"name":"前后端分离","slug":"前后端分离","link":"/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"name":"Elasticsearch","slug":"Elasticsearch","link":"/tags/Elasticsearch/"},{"name":"mvvm","slug":"mvvm","link":"/tags/mvvm/"},{"name":"数据绑定","slug":"数据绑定","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"}],"categories":[{"name":"Web前端","slug":"Web前端","link":"/categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"后端开发","slug":"后端开发","link":"/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"前后端分离","slug":"前后端分离","link":"/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}]}